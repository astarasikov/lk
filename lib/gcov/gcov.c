#include <ctype.h>
#include <stdlib.h>
#include <printf.h>
#include <stdio.h>
#include <string.h>

#if __GNUC__ == 4 && __GNUC_MINOR__ >= 9
#define GCOV_COUNTERS			9
#else
#define GCOV_COUNTERS			8
#endif

#define GCOV_TAG_FUNCTION_LENGTH	3

/*
 * Profiling data types used for gcc 3.4 and above - these are defined by
 * gcc and need to be kept as close to the original definition as possible to
 * remain compatible.
 */
#define GCOV_DATA_MAGIC		((unsigned int) 0x67636461)
#define GCOV_TAG_FUNCTION	((unsigned int) 0x01000000)
#define GCOV_TAG_COUNTER_BASE	((unsigned int) 0x01a10000)
#define GCOV_TAG_FOR_COUNTER(count)					\
	(GCOV_TAG_COUNTER_BASE + ((unsigned int) (count) << 17))

#if BITS_PER_LONG >= 64
typedef long gcov_type;
#else
typedef long long gcov_type;
#endif

/**
 * struct gcov_ctr_info - information about counters for a single function
 * @num: number of counter values for this type
 * @values: array of counter values for this type
 *
 * This data is generated by gcc during compilation and doesn't change
 * at run-time with the exception of the values array.
 */
struct gcov_ctr_info {
	unsigned int num;
	gcov_type *values;
};

/**
 * struct gcov_fn_info - profiling meta data per function
 * @key: comdat key
 * @ident: unique ident of function
 * @lineno_checksum: function lineo_checksum
 * @cfg_checksum: function cfg checksum
 * @ctrs: instrumented counters
 *
 * This data is generated by gcc during compilation and doesn't change
 * at run-time.
 *
 * Information about a single function.  This uses the trailing array
 * idiom. The number of counters is determined from the merge pointer
 * array in gcov_info.  The key is used to detect which of a set of
 * comdat functions was selected -- it points to the gcov_info object
 * of the object file containing the selected comdat function.
 */
struct gcov_fn_info {
	const struct gcov_info *key;
	unsigned int ident;
	unsigned int lineno_checksum;
	unsigned int cfg_checksum;
	struct gcov_ctr_info ctrs[0];
};

/**
 * struct gcov_info - profiling data per object file
 * @version: gcov version magic indicating the gcc version used for compilation
 * @next: list head for a singly-linked list
 * @stamp: uniquifying time stamp
 * @filename: name of the associated gcov data file
 * @merge: merge functions (null for unused counter type)
 * @n_functions: number of instrumented functions
 * @functions: pointer to pointers to function information
 *
 * This data is generated by gcc during compilation and doesn't change
 * at run-time with the exception of the next pointer.
 */
struct gcov_info {
	unsigned int version;
	struct gcov_info *next;
	unsigned int stamp;
	const char *filename;
	void (*merge[GCOV_COUNTERS])(gcov_type *, unsigned int);
	unsigned int n_functions;
	struct gcov_fn_info **functions;
};

/**
 * store_gcov_u32 - store 32 bit number in gcov format to buffer
 * @buffer: target buffer or NULL
 * @off: offset into the buffer
 * @v: value to be stored
 *
 * Number format defined by gcc: numbers are recorded in the 32 bit
 * unsigned binary form of the endianness of the machine generating the
 * file. Returns the number of bytes stored. If @buffer is %NULL, doesn't
 * store anything.
 */
static size_t store_gcov_u32(void *buffer, size_t off, u32 v)
{
	u32 *data;

	if (buffer) {
		data = buffer + off;
		*data = v;
	}

	return sizeof(*data);
}

/**
 * store_gcov_u64 - store 64 bit number in gcov format to buffer
 * @buffer: target buffer or NULL
 * @off: offset into the buffer
 * @v: value to be stored
 *
 * Number format defined by gcc: numbers are recorded in the 32 bit
 * unsigned binary form of the endianness of the machine generating the
 * file. 64 bit numbers are stored as two 32 bit numbers, the low part
 * first. Returns the number of bytes stored. If @buffer is %NULL, doesn't store
 * anything.
 */
static size_t store_gcov_u64(void *buffer, size_t off, u64 v)
{
	u32 *data;

	if (buffer) {
		data = buffer + off;

		data[0] = (v & 0xffffffffUL);
		data[1] = (v >> 32);
	}

	return sizeof(*data) * 2;
}

/*
 * Determine whether a counter is active. Doesn't change at run-time.
 */
static int counter_active(struct gcov_info *info, unsigned int type)
{
	return info->merge[type] ? 1 : 0;
}

/**
 * convert_to_gcda - convert profiling data set to gcda file format
 * @buffer: the buffer to store file data or %NULL if no data should be stored
 * @info: profiling data set to be converted
 *
 * Returns the number of bytes that were/would have been stored into the buffer.
 */
static size_t convert_to_gcda(char *buffer, struct gcov_info *info)
{
	struct gcov_fn_info *fi_ptr;
	struct gcov_ctr_info *ci_ptr;
	unsigned int fi_idx;
	unsigned int ct_idx;
	unsigned int cv_idx;
	size_t pos = 0;

	/* File header. */
	pos += store_gcov_u32(buffer, pos, GCOV_DATA_MAGIC);
	pos += store_gcov_u32(buffer, pos, info->version);
	pos += store_gcov_u32(buffer, pos, info->stamp);

	for (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {
		fi_ptr = info->functions[fi_idx];

		/* Function record. */
		pos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION);
		pos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION_LENGTH);
		pos += store_gcov_u32(buffer, pos, fi_ptr->ident);
		pos += store_gcov_u32(buffer, pos, fi_ptr->lineno_checksum);
		pos += store_gcov_u32(buffer, pos, fi_ptr->cfg_checksum);

		ci_ptr = fi_ptr->ctrs;

		for (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {
			if (!counter_active(info, ct_idx))
				continue;

			/* Counter record. */
			pos += store_gcov_u32(buffer, pos,
					      GCOV_TAG_FOR_COUNTER(ct_idx));
			pos += store_gcov_u32(buffer, pos, ci_ptr->num * 2);

			for (cv_idx = 0; cv_idx < ci_ptr->num; cv_idx++) {
				pos += store_gcov_u64(buffer, pos,
						      ci_ptr->values[cv_idx]);
			}

			ci_ptr++;
		}
	}

	return pos;
}

enum {
	DEFAULT_GCOV_ENTRY_COUNT = 200,
	GCOV_HEXDUMP_BUF_SIZE = 10000,
};

#define NUM_OCTETS_PER_LINE 20
#define OCTET_BUF_SZ (NUM_OCTETS_PER_LINE * 2 + 2)

typedef struct gcov_info *p_gcov_info;

//static p_gcov_info *gcov_info_head = NULL;
static p_gcov_info gcov_info_head[DEFAULT_GCOV_ENTRY_COUNT];
static size_t num_alloced_gcov_entries = DEFAULT_GCOV_ENTRY_COUNT;
static size_t num_used_gcov_entries = 0;

static void dump_gcov_entry(char *to_buffer, struct gcov_info *info)
{
	if (!info) {
		return;
	}

	size_t sz = convert_to_gcda(NULL, info);
	if (sz >= GCOV_HEXDUMP_BUF_SIZE) {
		printf("%s: size for '%s' is %d, limit %d\n",
				__func__, info->filename, sz,
				GCOV_HEXDUMP_BUF_SIZE);
		return;
	}
	sz = convert_to_gcda(to_buffer, info);

	char str[OCTET_BUF_SZ] = {};
	size_t cur = 0;
	while (cur < sz) {
		char *sptr = str;
		memset(str, 0x0, OCTET_BUF_SZ);
		size_t rem = NUM_OCTETS_PER_LINE;
		if ((sz - cur) < rem) {
			rem = (sz - cur);
		}
		int oct_no;
		for (oct_no = 0; oct_no < NUM_OCTETS_PER_LINE; oct_no++) {
			snprintf(sptr, 3, "%02x", to_buffer[cur + oct_no]);
			sptr += 2;
		}
		*sptr++ = '\n';
		*sptr++ = '\0';
		
		printf("%s", str);
		cur += NUM_OCTETS_PER_LINE;
	}

	printf("%s\n", info->filename);
}

void gcov_dump(void)
{
	static char *charbuf;
	size_t i;

	printf("%s\n", __func__);

	if (!gcov_info_head) {
		return;
	}

	if (!charbuf) {
		charbuf = malloc(GCOV_HEXDUMP_BUF_SIZE);
	}

	if (!charbuf) {
		printf("%s: failed to allocate memory\n", __func__);
		return;
	}

	for (i = 0; i < num_used_gcov_entries; i++) {
		memset(charbuf, 0, GCOV_HEXDUMP_BUF_SIZE);
		struct gcov_info *info = gcov_info_head[i];
		dump_gcov_entry(charbuf, info);
	}
}

void __gcov_init(struct gcov_info *info)
{
	if (!info) {
		printf("%s: bogus NULL info\n", __func__);
		return;
	}
	printf("%s filename='%s'\n", __func__, info->filename);

#if 0
	if (num_alloced_gcov_entries <= num_used_gcov_entries) {
		size_t odata_sz = num_alloced_gcov_entries * sizeof(p_gcov_info);
		size_t ndata_sz = 2 * odata_sz;

		p_gcov_info *ndata = malloc(ndata_sz);
		if (!ndata) {
			goto oom;
		}
		memset(ndata, 0, ndata_sz);
		memcpy(ndata, gcov_info_head, odata_sz);
		
		p_gcov_info *odata = gcov_info_head;
		gcov_info_head = ndata;
		free(odata);
	}

	if (!gcov_info_head) {
		size_t ndata_sz = DEFAULT_GCOV_ENTRY_COUNT * sizeof(p_gcov_info);
		gcov_info_head = malloc(ndata_sz);
	
		if (!gcov_info_head) {
			goto oom;
		}
		else {
			memset(gcov_info_head, 0, ndata_sz);
		}
	}
#endif

	if (num_used_gcov_entries >= DEFAULT_GCOV_ENTRY_COUNT) {
		printf("%s: gcov_info_head is full, all %d entries used\n",
				__func__, num_used_gcov_entries);
		return;
	}
	gcov_info_head[num_used_gcov_entries++] = info;
	return;
oom:
	printf("%s: failed to allocate memory\n", __func__);
}

void __gcov_merge_add(gcov_type *counters, unsigned int n_counters)
{
	printf("%s\n", __func__);
}
